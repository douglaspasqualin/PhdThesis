\chapter{Conclusion}\label{chap:conclusion}

Transactional memory (TM) provides a high-level abstraction for thread synchronization in parallel programming. It can be implemented in hardware (HTM), software (STM), or both (hybrid). This thesis focused on STM. There are many studies on how to improve the performance of STM systems. Most of them focus on reducing the number of aborts, using different techniques, such as contention managements and transactional schedulers. Although reducing the number of aborts improves the performance, this thesis showed that in current multicore architectures with complex memory hierarchies it is also important to consider where the memory of the program is located and how it is accessed. Thus, the placement of threads and data is important to performance, improving the locality of memory accesses. Hence, this thesis used the concept of \emph{sharing-aware mapping}, which aims to map threads and data of an application considering their memory access behavior. Besides, STM provides interesting mapping opportunities since the STM runtime has precise information about memory areas that are shared between threads, their respective memory addresses, and the intensity with which they are accessed by each thread.

The first contribution of this thesis~(Chapter~\ref{chap:mechanism}) is a mechanism to detect the sharing behavior of STM applications. Since the STM runtime needs the memory address on each data access operation and has precise information about shared variables, it is possible to determine the communication behavior by tracking transactional reads and writes instead of all memory accesses. Using the proposed mechanism it was possible to extract the sharing behavior of STM applications with lower overhead than other memory trace tools.

The second thesis contribution~(Chapter~\ref{chap:charact}) is a characterization of the sharing behavior of STM applications. This characterization is important to guide decisions regarding mapping, such as determining if an application is suitable for a thread mapping based on communication behavior and defining the type of mapping policy (static or dynamic). The main findings are that most of the characterized STM applications are suitable for a static thread mapping approach to improve the performance since (1) the applications do not present dynamic behavior and (2) the sharing pattern does not change between executions. Furthermore, it was shown that the sharing information gathered from the STM runtime can be used to analyze and reduce false sharing in STM applications.

Using the proposed mechanism to detect the sharing behavior and the characterization of the sharing behavior of STM applications, it was proposed two mechanisms to perform sharing-aware thread mapping for STM applications. The first mechanism is \emph{static}~(Chapter~\ref{chap:sharAwareThreadMap}, Section~\ref{sect:staticThreadMap}), i.e., where threads are mapped to cores at the beginning of execution, based on a previous analysis of the sharing behavior of the application. This mechanism was called as Static-SharingAware~(SSA). The second mechanism, STMap~(Chapter~\ref{chap:sharAwareThreadMap}, Section~\ref{sect:onlineThreadMapping}), does not need prior information about the sharing behavior of the application, since the detection of sharing behavior and thread migration are performed based on information gathered solely during execution. In experiments with the \texttt{STAMP} benchmark suite and synthetic benchmarks, both mechanisms showed performance gains when compared to the default Linux scheduler. We conclude that applications that are suitable for a sharing-aware thread mapping, in general, present a low number of distinct addresses accessed by the STM runtime with a lot of accesses in these addresses. Also, applications with low and medium contention had higher gains. Even though the experiments were focused on the \texttt{STAMP} benchmark, we expect that the observed results can be generalized for a wide range of STM applications since \texttt{STAMP} was developed to represent realistic workload characteristics and it covers a wide range of transactional behavior.

Albeit this thesis focuses on sharing-aware thread mapping, in Appendix~\ref{chap:sharAwareDataMap} we show how STMap can be extended to include sharing-aware data mapping. 
	
%Although initial results using a synthetic application were encouraging, data mapping did not improve performance when using \texttt{STAMP}. Contrary to thread mapping, where only keeping track of STM operations is sufficient to perform an effective thread mapping, data mapping requires a global vision of memory page accesses of the application to be able to improve the performance, which STM runtimes can not provide.}

%Finally, it was presented how STMap can be extended to include sharing-aware data mapping. Using a synthetic array sum application, the proposed mechanism increased the performance on NUMA machines with high latency on remote memory access.

\section{Future work}

The research presented in this thesis can be extended in the following ways:

\begin{itemize}
	\item \textbf{Include balance on thread mapping}. Both SSA and STMap uses \texttt{TopoMatch} to calculated the thread mapping. As described in Section~\ref{sec:calculatemap}, when calculating the new thread mapping, \texttt{TopoMatch} tries to minimize the communication costs between sockets/nodes. Hence, it prioritizes the placement of threads first inside the same socket. However, as shown in the experiments, applications such as \emph{Genome} and \emph{Labyrinth} prefers mapping that reduces memory contention, i.e., balance instead of locality. This characteristic can be explored in future extensions of STMap.
	
	\item \textbf{Identify false sharing}. We showed in Chapter~\ref{chap:charact} that it is possible to identify false sharing of cache lines of STM operations using the proposed mechanism to detect the sharing behavior of STM applications. In HTM, false sharing is one of the main causes of conflicts, since the granularity of conflict detection is normally the cache line. Hence, the mechanism proposed in this thesis could be extended to detected false sharing, reducing the number of conflicts in HTM applications.
\end{itemize}